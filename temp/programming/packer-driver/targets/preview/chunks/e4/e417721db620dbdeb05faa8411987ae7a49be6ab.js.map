{"version":3,"sources":["file:///D:/ThanhPhong/FE02/Project-FrontEnd2/assets/Scripts/Pipes.ts"],"names":["_decorator","Component","Node","Vec3","screen","find","UITransform","log","view","Game","ccclass","property","random","min","max","Math","Pipes","type","tooltip","tempStartLocationUp","tempStartLocationDown","scene","windowSize","game","bird","pipeSpeed","tempSpeed","isPass","onLoad","gameControl","getComponent","Scroll","speed","initPos","visibleSize","getVisibleSize","width","x","topPipe","bottomPipe","gap","topHeight","y","setPosition","tempPos","node","getPosition","update","deltaTime","state","abs","position","getWorldPosition","destroy"],"mappings":"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","sourcesContent":["import { _decorator, Component, Node, Vec3, screen, find, UITransform, log, director, view } from 'cc';\n\nimport { Game } from './Game';\nimport { Bird } from './Bird';\n\nconst { ccclass, property } = _decorator;\n\n//make a random number generator for the gap\nconst random = (min, max) =>\n{\n    return Math.random() * (max - min) + min\n}\n\n@ccclass('Pipes')\nexport class Pipes extends Component\n{\n    @property({ type: Node, tooltip: 'Top Pipe' })\n    public topPipe: Node;\n\n    @property({ type: Node, tooltip: 'Bottom Pipe' })\n    public bottomPipe: Node;\n\n    //temporary Locations\n    public tempStartLocationUp: Vec3 = new Vec3(0, 0, 0);  //Temporary location of the up pipe\n    public tempStartLocationDown: Vec3 = new Vec3(0, 0, 0); //Temporary location of the bottom pipe\n    public scene = screen.windowSize; //get the size of the screen in case we decide to change the content size\n\n    //get the pipe speeds\n    public game: Game; //get the pipe speed from GameCtrl\n    public bird: Bird;\n    public pipeSpeed: number; //use as a final speed number\n    public tempSpeed: number; //use as the moving pipe speed\n\n    //scoring mechanism\n    isPass: boolean; //Did the pipe pass the bird?\n\n    protected onLoad (): void\n    {\n\n        //first search the gamec control\n        let gameControl = find(\"GameCtrl\");\n        if (gameControl == null)\n        {\n            log(\"GameCtrl not found\");\n            return;\n        }\n        else\n        {\n            this.game = gameControl.getComponent(Game);\n            this.bird = this.game.bird;\n        }\n        \n\n        //add pipespeed to temporary method\n        this.pipeSpeed = this.game.Scroll.speed;\n\n        //set the original position\n        this.initPos();\n\n        //set the scoring mechanism to stop activating\n        this.isPass = false;\n    }\n\n    //initial positions of the grounds\n    initPos ()\n    {   \n        const visibleSize = view.getVisibleSize();\n\n        let width = visibleSize.width;\n\n        //start with the initial position of x for both pipes\n        this.tempStartLocationUp.x = (this.topPipe.getComponent(UITransform).width + width);\n        this.tempStartLocationDown.x = (this.bottomPipe.getComponent(UITransform).width + width);\n\n        //random variables for the gaps\n        // let gap = random(50, 50);  //passable area randomized. \n        let gap = 50;  //passable area.\n        let topHeight = random(-30, 150);   //The height of the top pipe\n\n        this.tempStartLocationUp.y = gap;\n        this.tempStartLocationDown.y = -gap;\n\n        //set temp locations to real ones\n        this.topPipe.setPosition(this.tempStartLocationUp.x, this.tempStartLocationUp.y);\n        this.bottomPipe.setPosition(this.tempStartLocationDown.x, this.tempStartLocationDown.y);\n\n        let tempPos = this.node.getPosition();\n        tempPos.y = topHeight;\n        this.node.setPosition(tempPos);\n    }\n\n    //move the pipes as we update the game\n    //this just moves a pair of pipes top and down\n    protected update (deltaTime: number): void\n    {\n        // if(this.game.isOver==false) return;\n        if(this.bird==null)\n        {\n            log(\"bird is null\");\n            return;\n        }\n        if (this.bird.state == 0 || this.bird.state==2) return;\n        //get the pipe speed\n        this.tempSpeed = Math.abs(this.pipeSpeed * deltaTime);\n\n        //make temporary pipe locations\n        this.tempStartLocationDown = this.bottomPipe.position;\n        this.tempStartLocationUp = this.topPipe.position;\n\n        //move temporary pipe locations\n        this.tempStartLocationDown.x -= this.tempSpeed;\n        this.tempStartLocationUp.x -= this.tempSpeed;\n\n        //place new positions of the pipes from temporary pipe locations\n        this.bottomPipe.setPosition(this.tempStartLocationDown);\n        this.topPipe.setPosition(this.tempStartLocationUp);\n\n        // //find out if bird past a pipe, add to the score\n        // if (this.isPass == false && this.topPipe.position.x <= 0)\n        // {\n\n        //     //make sure it is only counted once\n        //     this.isPass = true;\n\n        //     //add a point to the score\n        //     // this.game.passPipe();\n\n        // };\n\n        //if passed the screen, reset pipes to new location\n        if (this.topPipe.getWorldPosition().x < (0 - this.scene.width))\n        {\n            //create a new pipe\n            // this.game.createPipe();\n\n            //delete this node for memory saving\n            this.destroy();\n        };\n\n    }\n}\n\n\n"]}